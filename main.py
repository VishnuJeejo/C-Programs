# -*- coding: utf-8 -*-
"""Model Traning Final final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13JGRhhp4GEhVg6AC7ocZU5Kz-3y_iazx
"""

import tensorflow as tf                             
from matplotlib import pyplot as plt                        
import numpy as np

from keras.datasets import mnist
objects=mnist
(train_img,train_lab),(test_img,test_lab)=objects.load_data()

for i in range(20):
  plt.subplot(4,5,i+1)
  plt.imshow(train_img[i],cmap='gray_r')
  plt.title("Digit : {}".format(train_lab[i]))
  plt.subplots_adjust(hspace=0.5)
  plt.axis('off')

print('Training images shape : ',train_img.shape)
print('Testing images shape : ',test_img.shape)

print('How image looks like : ')
print(train_img[0])

plt.hist(train_img[0].reshape(784),facecolor='orange')
plt.title('Pixel vs its intensity',fontsize=16)
plt.ylabel('PIXEL')
plt.xlabel('Intensity')

train_img=train_img/255.0
test_img=test_img/255.0

train_img = train_img.reshape(-1,28,28,1)    #training set
test_img = test_img.reshape(-1,28,28,1)      #test set

print('How image looks like after normalising: ')
print(train_img[0])

plt.hist(train_img[0].reshape(784),facecolor='orange')
plt.title('Pixel vs its intensity',fontsize=16)
plt.ylabel('PIXEL')
plt.xlabel('Intensity')

import random
import numpy as np
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
import pathlib
import PIL

from keras.models import Sequential
from keras.layers import Flatten,Dense
from tensorflow.keras.layers import Input,Conv2D,MaxPooling2D,Conv2DTranspose
#class_names = train_img.class_names
#num_classes = len(class_names)
cnnModel= Sequential()
cnnModel.add(Conv2D(64, (5,5) , padding = 'same', activation="relu", input_shape=(28,28,1)))
cnnModel.add(Conv2D(64, (5,5) , padding = 'same', activation="relu"))
#cnnModel.add(Conv2D(64, (5,5) , padding = 'same', activation="relu"))
cnnModel.add(MaxPooling2D((2,2)))
cnnModel.add(Conv2D(128, (5,5) , padding = 'same', activation="relu"))
cnnModel.add(Conv2D(128, (5,5) , padding = 'same', activation="relu"))
cnnModel.add(MaxPooling2D((2,2)))
cnnModel.add(Conv2D(256, (5,5) , padding = 'same', activation="relu"))
cnnModel.add(Conv2D(256, (5,5) , padding = 'same', activation="relu"))
#cnnModel.add(Conv2D(256, (5,5) , padding = 'same', activation="relu"))
cnnModel.add(MaxPooling2D((2,2)))

cnnModel.add(Conv2D(512, (5,5) , padding = 'same', activation="relu"))
cnnModel.add(Conv2D(512, (5,5) , padding = 'same', activation="relu"))
#cnnModel.add(Conv2D(512, (5,5) , padding = 'same', activation="relu"))
cnnModel.add(MaxPooling2D((2,2)))
#cnnModel.add(Conv2D(512, (3,3) , padding = 'same', activation="relu"))
#cnnModel.add(Conv2D(512, (3,3) , padding = 'same', activation="relu"))
#cnnModel.add(Conv2D(512, (3,3) , padding = 'same', activation="relu"))
#cnnModel.add(MaxPooling2D((2,2)))
cnnModel.add(Flatten())
cnnModel.add(Dense(300,activation="relu"))
cnnModel.add(Dense(400,activation="relu"))
cnnModel.add(Dense(10,activation="softmax"))
cnnModel.summary()

#compiling the sequential model
cnnModel.compile(optimizer='adam',loss="sparse_categorical_crossentropy",metrics=["accuracy"])
history_seq = cnnModel.fit(train_img,train_lab,epochs=10,batch_size=128,verbose=1,validation_split=0.1)

testLoss, testAccuracy =cnnModel.evaluate(test_img,test_lab)
print("Test Loss =", testLoss*100)
print("Test Accuracy =", testAccuracy*100)

pd.DataFrame(history_seq.history).plot()
plt.grid(True)
plt.xlabel("epochs")
plt.ylabel("loss/accuracy")
plt.title("Training and validation plot")
plt.show()

from google.colab import drive
drive.mount('/content/gdrive')

!ls

cd 'MyDrive'

model.save('MyDrive/project.h5')

loss_and_acc=model.evaluate(test_img,test_lab,verbose=2)
print("Test Loss", loss_and_acc[0])
print("Test Accuracy", loss_and_acc[1])

plt.imshow(test_img[0],cmap='gray_r')
plt.title('Actual Value: {}'.format(test_lab[0]))
prediction=model.predict(test_img)
plt.axis('off')
print('Predicted Value: ',np.argmax(prediction[0]))
if(test_lab[0]==(np.argmax(prediction[0]))):
  print('Successful prediction')
else:
  print('Unsuccessful prediction')

plt.imshow(test_img[1],cmap='gray_r')
plt.title('Actual Value: {}'.format(test_lab[1]))
prediction=model.predict(test_img)
plt.axis('off')
print('Predicted Value: ',np.argmax(prediction[1]))
if(test_lab[1]==(np.argmax(prediction[1]))):
  print('Successful prediction')
else:
  print('Unsuccessful prediction')

plt.imshow(test_img[2],cmap='gray_r')
plt.title('Actual Value: {}'.format(test_lab[2]))
prediction=model.predict(test_img)
plt.axis('off')
print('Predicted Value: ',np.argmax(prediction[2]))
if(test_lab[2]==(np.argmax(prediction[2]))):
  print('Successful prediction')
else:
  print('Unsuccessful prediction')

# make a prediction for a new image.
from keras.preprocessing.image import load_img
from keras.preprocessing.image import img_to_array
from keras.models import load_model
 
# load and prepare the image
def load_image(filename):
	# load the image
	img = load_img(filename, grayscale=True, target_size=(28, 28))
	# convert to array
	img = img_to_array(img)
	# reshape into a single sample with 1 channel
	img = img.reshape(1, 28, 28)
	# prepare pixel data
	img = img.astype('float32')
	img = img / 255.0
	return img

from google.colab import files
uploaded = files.upload()

from IPython.display import Image
Image('0.jpg',width=250,height=250)

img = load_image('0.jpg')
digit=model.predict(img)
print('Predicted value : ',np.argmax(digit))

from google.colab import files
uploaded = files.upload()

from IPython.display import Image
Image('7.jpg')

img = load_image('7.jpg')
digit=model.predict(img)
print(np.argmax(digit))

from google.colab import files
uploaded = files.upload()

Image('2.jpg')

img = load_image('2.jpg')
digit=model.predict(img)
print(np.argmax(digit))

new_model=tf.keras.models.load_model('project.h5')

from google.colab import files
uploaded = files.upload()

from IPython.display import Image
Image('0.jpg')

img = load_image('0.jpg')
digit=new_model.predict(img)
print(np.argmax(digit))
